<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <!-- å›ºå®šå®½åº¦320px -->
  <meta name="viewport" content="width=320, initial-scale=1.0" />
  <title>ä¼°ç®—è®¡ç®—å™¨</title>
  â€‹â€‹<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='0.9em' font-size='90'>ğŸ§®</text></svg>">
  <style>
    /* å…¨å±€æ ·å¼ */
    body {
      --max-width: 360px; /* ä¸ä¸»æ¡†æ¶æœ€å¤§å®½åº¦ä¸€è‡´ */
      font-family: Arial, sans-serif;
      background-color: #f0f0f0;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      margin: 0;
      padding: 10px;
    }
    /* è¿”å›é¦–é¡µæŒ‰é’®æ ·å¼ */
    #backHomeBtn {
  position: fixed;
  top: 10px;
  left: max(5%, calc(50% - min(90%, var(--max-width)) / 2));
  z-index: 10000;
  padding: 3px 8px;
  background-color: rgba(147, 112, 219, 0.67); /* æ·»åŠ é€æ˜åº¦ */
  color: #fff;
  border: none;
  border-radius: 4px;
  font-size: 12px;
  font-weight: bold;
  font-family: "å¾®è½¯é›…é»‘", Arial, sans-serif;
  cursor: pointer;
  box-shadow: 0 2px 4px rgba(0,0,0,0.25);
  transition: background-color 0.3s;
}
#backHomeBtn:hover {
      background-color: rgba(122, 95, 181, 0.95); /* æ‚¬åœæ—¶æ›´é€æ˜ */
      opacity: 0.95;
}
    .calculator {
      background: #fff;
      border-radius: 10px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
      padding: 20px;
      width: 320px;
    }
    /* æ˜¾ç¤ºåŒºï¼šé«˜åº¦70px */
    .display {
      width: 100%;
      height: 70px;
      background: #4E5359;
      color: #0f0;
      padding: 10px;
      border-radius: 5px;
      font-size: 2.8em;
      display: flex;
      align-items: flex-end;
      justify-content: flex-end;
      overflow-x: auto;
      box-sizing: border-box;
      text-align: center;
    }
    /* ç»Ÿä¸€ä¸‹ç§»ï¼Œç”¨äºç»“æœæ˜¾ç¤º */
    .primaryAns, .separator, .secondaryContainer {
      position: relative;
      vertical-align: middle;
    }
    .primaryAns, .secondaryContainer {
      top: 5px;
    }
    /* è¾“å…¥ç®—å¼æ—¶çš„åŒ…è£… */
    .inputExpr {
      position: relative;
      top: 5px;
    }
    /* æŒ‰é”®åŒº */
    .buttons {
      margin-top: 10px;
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
    }
    button {
      padding: 10px;
      font-size: 1.2em;
      border: none;
      border-radius: 5px;
      background: #e0e0e0;
      cursor: pointer;
      transition: background 0.3s;
    }
    button:hover {
      background: #d4d4d4;
    }
    /* åŠŸèƒ½é”® */
    .operator { background: #ff9500; color: #fff; }
    .approximate { background: #5856d6; color: #fff; }
    .approximate.disabled { background: #b0b0b0; color: #888; cursor: not-allowed; }
    .approximate.disabled:hover { background: #b0b0b0; }
    .clear { background: #fc6159; color: #fff; }
    .backspace { background: #ffcc00; color: #fff; }
    .equals { background: #34c759; color: #fff; }
    .exponent { background: #e0e0e0; }
    .paren { background: #e0e0e0; }
    .span-2 { grid-column: span 2; }
    .span-4 { grid-column: span 4; }
    .explanation {
      margin-top: 20px;
      font-size: 1em;
      color: #333;
      line-height: 1.5;
      height: 120px;
      overflow-y: auto;
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 5px;
      background: #fafafa;
      white-space: pre-wrap;
    }
    .explanation.centered {
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      white-space: normal;
    }
    .explanation.has-content {
      display: block;
      text-align: left;
      white-space: pre-wrap;
    }
    .primaryAns { 
      font-weight: normal; 
      color: inherit; 
      vertical-align: bottom;
      margin-right: -4px;
    }
    .separator { 
      vertical-align: bottom; 
      font-size: 0.7em; 
      margin-left: 10px; 
      margin-right: 2px; 
      color: #fff; 
    }
    .secondaryContainer {
      display: inline-block;
      vertical-align: bottom;
      min-height: 1.2em;
    }
    .secondaryLabel {
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translate(-50%, 100%);
      font-size: 0.27em;
      color: inherit;
      line-height: 1;
      white-space: nowrap;
    }
    .secondaryAns {
      font-size: 0.6em;
      font-weight: normal;
      color: #2fa9ff;
    }
    .parenBtnLeft, .parenBtnRight { 
      font-size: 0.9em; 
      margin: 0 5px; 
    }
    .exprParen { 
      position: relative; 
      top: -0.3em; 
      font-size: 0.75em; 
      margin-left: 8px; 
      margin-right: 8px; 
    }
    .answerMinus { 
      display: inline-block; 
      font-size: 2em; 
      position: relative; 
      top: -2em; 
    }
    .estimatePrefix { 
      font-size: 0.8em; 
      vertical-align: middle; 
      margin-right: 1px; 
    }
  </style>
</head>
<body>
    <!--  è¿”å›ä¸»é¡µæŒ‰é’® -->
<button id="backHomeBtn" onclick="window.location.href='../index.html'">â†è¿”å›ä¸»é¡µ</button>
  <div class="calculator">
    <!-- æ˜¾ç¤ºåŒº -->
    <div id="display" class="display"></div>
    <div class="buttons">
      <!-- ç¬¬ä¸€è¡Œ -->
      <button class="clear span-2" onclick="clearDisplay()">C</button>
      <button class="backspace span-2" onclick="backspace()">â†</button>
      <!-- ç¬¬äºŒè¡Œ -->
      <button onclick="appendValue('7')">7</button>
      <button onclick="appendValue('8')">8</button>
      <button onclick="appendValue('9')">9</button>
      <button class="operator" onclick="appendValue('Ã·')">Ã·</button>
      <!-- ç¬¬ä¸‰è¡Œ -->
      <button onclick="appendValue('4')">4</button>
      <button onclick="appendValue('5')">5</button>
      <button onclick="appendValue('6')">6</button>
      <button class="operator" onclick="appendValue('Ã—')">Ã—</button>
      <!-- ç¬¬å››è¡Œ -->
      <button onclick="appendValue('1')">1</button>
      <button onclick="appendValue('2')">2</button>
      <button onclick="appendValue('3')">3</button>
      <button class="operator" onclick="appendValue('-')">-</button>
      <!-- ç¬¬äº”è¡Œ -->
      <button onclick="appendValue('.')">.</button>
      <button onclick="appendValue('0')">0</button>
      <button id="estimateBtn" class="approximate" onclick="estimate()">â‰ˆ</button>
      <button class="operator" onclick="appendValue('+')">+</button>
      <!-- ç¬¬å…­è¡Œ -->
      <button class="exponent" onclick="exponentOp()">X<sup>y</sup></button>
      <!-- æ‹¬å·æŒ‰é’® -->
      <button class="paren" onclick="toggleParen()">
        <span class="parenBtnLeft">(</span><span class="parenBtnRight">)</span>
      </button>
      <button class="equals span-2" onclick="equalsPressed()">=</button>
    </div>
    <!-- è§£é‡ŠåŒºåŸŸ -->
    <div id="explanation" class="explanation centered">
      è¿™é‡Œæ˜¯ä¼°ç®—è§£é‡ŠåŒºåŸŸã€‚å½“ä½¿ç”¨"â‰ˆ"æŒ‰é’®æ—¶ï¼Œå°†æ˜¾ç¤ºå„è§„åˆ™å€™é€‰ä¼°å€¼åŠæ³¨é‡Šã€‚
    </div>
  </div>

  <script>
    //â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // ç‰¹æ®Šå››èˆäº”å…¥ï¼šå¯¹æ­£æ•° x æŒ‰ä¸ªä½å¤„ç† â€”â€” è‹¥ä½™æ•°å°äº5åˆ™èˆå»ï¼›å¤§äº5åˆ™è¿›ä½ï¼›ç­‰äº5åˆ™ä¸å˜
    function specialResultRound(x) {
      let rem = x % 10;
      if (rem < 5) return x - rem;
      else if (rem > 5) return x + (10 - rem);
      else return x;
    }

    // æ–°å¢ï¼šè·å–å°¾éƒ¨ç‰¹å¾çš„å‡½æ•°
    function getTrailingFeatures(num) {
      const absNum = Math.abs(Math.round(num));
      if (absNum === 0) return { trailingZeros: 1, zeroAndFiveCount: 1 };

      const numStr = String(absNum);
      let trailingZeros = 0;
      let zeroAndFiveCount = 0;

      // è®¡ç®—æœ«å°¾è¿ç»­é›¶
      for (let i = numStr.length - 1; i >= 0; i--) {
        if (numStr[i] === '0') {
          trailingZeros++;
        } else {
          break;
        }
      }

      // ç»Ÿè®¡0å’Œ5çš„æ€»æ•°
      for (const digit of numStr) {
        if (digit === '0' || digit === '5') {
          zeroAndFiveCount++;
        }
      }

      return {
        trailingZeros: Math.min(trailingZeros, 10),
        zeroAndFiveCount: Math.min(zeroAndFiveCount, 20)
      };
    }

    // æ–°å¢ï¼šç»Ÿä¸€ç»“æœå¤„ç†å‡½æ•°
    function processResults(candidates, exactValue) {
      // ç§»é™¤ç²¾ç¡®å€¼å€™é€‰é¡¹
      let estimatedCandidates = candidates.filter(item => item.method !== "ç²¾ç¡®å€¼");

      // è®¡ç®—ç›¸å¯¹è¯¯å·®å¹¶æ·»åŠ åˆ°å€™é€‰é¡¹ä¸­
      estimatedCandidates = estimatedCandidates.map(item => ({
        ...item,
        relativeError: Math.abs(item.candidate - exactValue) / Math.abs(exactValue) * 100
      }));

      // ç­›é€‰ç›¸å¯¹è¯¯å·®èŒƒå›´å†…çš„å€™é€‰
      let workingCandidates = estimatedCandidates.filter(item => item.relativeError <= 10);
      if (workingCandidates.length <= 1) {
        workingCandidates = estimatedCandidates.filter(item => item.relativeError <= 20);
      }

      // ä¸ºå€™é€‰å€¼å¢åŠ æ•´æ•°éƒ¨åˆ†å­—æ®µï¼ˆå››èˆäº”å…¥åçš„æ•´æ•°éƒ¨åˆ†ï¼‰
      workingCandidates = workingCandidates.map(item => ({
        ...item,
        integerValue: Math.round(item.candidate)
      }));

      // å»é‡ï¼šä»…ä¿ç•™ä¸åŒæ•´æ•°éƒ¨åˆ†çš„å€™é€‰
      let seen = new Set();
      workingCandidates = workingCandidates.filter(item => {
        if (seen.has(item.integerValue)) {
          return false;
        }
        seen.add(item.integerValue);
        return true;
      });

      // é‡æ–°æ’åºï¼ˆæŒ‰ä¸ç²¾ç¡®å€¼çš„ç»å¯¹è¯¯å·®ä»å°åˆ°å¤§ï¼‰
      workingCandidates.forEach(item => {
        item.error = Math.abs(item.candidate - exactValue);
      });
      workingCandidates.sort((a, b) => a.error - b.error);

      let exactInt = Math.round(exactValue);
      let sameCandidates = workingCandidates.filter(item => item.integerValue === exactInt);
      let differentCandidates = workingCandidates.filter(item => item.integerValue !== exactInt);

      let primaryResult = null;
      let secondaryResult = null;

      // å¦‚æœå€™é€‰å€¼åªæœ‰ä¸¤ä¸ª
      if (workingCandidates.length === 2) {
        if (sameCandidates.length === 1 && differentCandidates.length === 1) {
          // ä¸ç²¾ç¡®å€¼ç›¸åŒçš„ä½œä¸ºæ¬¡é€‰ï¼Œä¸åŒçš„ä½œä¸ºé¦–é€‰
          primaryResult = differentCandidates[0].candidate;
          secondaryResult = sameCandidates[0].candidate;
        } else {
          primaryResult = workingCandidates[0].candidate;
          secondaryResult = workingCandidates[1].candidate;
        }
      } else {
        // å¤šäºä¸¤ä¸ªå€™é€‰å€¼æ—¶
        if (differentCandidates.length > 0) {
          primaryResult = differentCandidates[0].candidate;
          if (differentCandidates.length > 1) {
            secondaryResult = differentCandidates[1].candidate;
          } else if (sameCandidates.length > 0) {
            secondaryResult = sameCandidates[0].candidate;
          }
        } else if (sameCandidates.length > 0) {
          primaryResult = sameCandidates[0].candidate;
        } else {
          primaryResult = Math.floor(exactValue);
        }

        // å¦‚æœåˆé€‰ç»“æœä¸ç²¾ç¡®ç»“æœæ•´æ•°éƒ¨åˆ†ç›¸åŒï¼Œåˆ™é‡æ–°é€‰ä¸€ä¸ªä¸åŒçš„å€™é€‰ä½œä¸ºä¸»ç»“æœ
        if (Math.round(primaryResult) === exactInt && differentCandidates.length > 0) {
          primaryResult = differentCandidates[0].candidate;
          let nextCandidate = workingCandidates.find(item => Math.round(item.candidate) !== Math.round(primaryResult));
          if (nextCandidate) {
            secondaryResult = nextCandidate.candidate;
          }
        }
      }

      return {
        primary: primaryResult !== null ? primaryResult : "",
        secondary: secondaryResult !== null ? secondaryResult : ""
      };
    }

    // æ–°å¢ï¼šæ£€æŸ¥è¡¨è¾¾å¼æ˜¯å¦æ”¯æŒä¼°ç®—
    function canEstimate(expr) {
      if (!expr || expr.trim() === "") return false;
      
      // æ”¯æŒçš„ä¼°ç®—æ ¼å¼ï¼ša+b, a-b, aÃ—b, aÃ·b
      const supportedPattern = /^(-?\d+(?:\.\d+)?)([+\-Ã—Ã·/])(-?\d+(?:\.\d+)?)$/;
      return supportedPattern.test(expr.replace(/\s/g, ''));
    }

    // æ–°å¢ï¼šæ›´æ–°ä¼°ç®—æŒ‰é”®çŠ¶æ€çš„å‡½æ•°
    function updateEstimateButtonState() {
      const estimateBtn = document.getElementById('estimateBtn');
      const resultType = display.getAttribute("data-type");
      
      if (resultType === "estimate") {
        // å½“å‰æ˜¾ç¤ºä¼°ç®—ç»“æœï¼Œç¦ç”¨ä¼°ç®—æŒ‰é”®
        estimateBtn.classList.add('disabled');
      } else if (!canEstimate(exprString)) {
        // è¡¨è¾¾å¼ä¸æ”¯æŒä¼°ç®—ï¼Œç¦ç”¨ä¼°ç®—æŒ‰é”®
        estimateBtn.classList.add('disabled');
      } else {
        // å…¶ä»–çŠ¶æ€ï¼Œå¯ç”¨ä¼°ç®—æŒ‰é”®
        estimateBtn.classList.remove('disabled');
      }
    }

    // æ–°å¢ï¼šè®¾ç½®è§£é‡ŠåŒºä¸ºé»˜è®¤çŠ¶æ€
    function setExplanationDefault() {
      explanationDiv.className = "explanation centered";
      explanationDiv.textContent = 'è¿™é‡Œæ˜¯ä¼°ç®—è§£é‡ŠåŒºåŸŸã€‚å½“ä½¿ç”¨"â‰ˆ"æŒ‰é’®æ—¶ï¼Œå°†æ˜¾ç¤ºå„è§„åˆ™å€™é€‰ä¼°å€¼åŠæ³¨é‡Šã€‚';
    }

    // æ–°å¢ï¼šè®¾ç½®è§£é‡ŠåŒºä¸ºæœ‰å†…å®¹çŠ¶æ€
    function setExplanationContent(content) {
      explanationDiv.className = "explanation has-content";
      explanationDiv.innerHTML = content;
    }
    //â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    // æ ¹æ®æ•°å€¼å¤§å°ç¡®å®šç²¾åº¦å•ä½
    function getPrecision(num) {
      let absNum = Math.abs(num);
      if (absNum < 10) return 1;
      else if (absNum < 100) return 10;
      else if (absNum < 1000) return 100;
      else if (absNum < 10000) return 1000;
      else return Math.pow(10, Math.floor(Math.log10(absNum)));
    }
    
    // å–ä¸€ä¸ªæ•°çš„é¦–ä½ä¼°ç®—å€¼
    function floorToMSD(num) {
      let absNum = Math.abs(num);
      if (absNum < 10) return num;
      let scale = Math.pow(10, Math.floor(Math.log10(absNum)));
      return Math.floor(num / scale) * scale;
    }
    
    const display = document.getElementById('display');
    const explanationDiv = document.getElementById('explanation');
    let exprString = "";
    let lastExpression = "";
    let equalsPressCount = 0;
    
    // æ ¼å¼åŒ–è¡¨è¾¾å¼ï¼Œå°†æ‹¬å·ç”¨ span åŒ…è£¹
    function formatExpression(str) {
      str = str.replace(/\)\(/g, ') (');
      return str.replace(/([\(\)])/g, '<span class="exprParen">$1</span>');
    }
    
    function appendValue(val) {
      equalsPressCount = 0;
      if (display.getAttribute("data-result") === "true") {
        const resultType = display.getAttribute("data-type") || "";
        if (resultType === "estimate") { 
          exprString = ""; 
        } else if (resultType === "calc") { 
          if (/^[0-9.]$/.test(val)) { exprString = ""; } 
        }
        display.removeAttribute("data-result");
        display.removeAttribute("data-type");
      }
      if (val === 'Ã—' || val === 'Ã·') {
        if (exprString.length > 0 && /[+\-Ã—Ã·]$/.test(exprString)) {
          exprString = exprString.slice(0, -1);
        }
      }
      exprString += val;
      display.innerHTML = '<span class="inputExpr">' + formatExpression(exprString) + '</span>';
      
      // ä¿®æ”¹ï¼šæ ¹æ®è¡¨è¾¾å¼å†…å®¹æ›´æ–°è§£é‡ŠåŒº
      if (exprString.trim() === "") {
        setExplanationDefault();
      } else {
        explanationDiv.className = "explanation has-content";
        explanationDiv.textContent = exprString;
      }
      
      updateEstimateButtonState(); // æ›´æ–°æŒ‰é”®çŠ¶æ€
    }
    
    function clearDisplay() {
      exprString = "";
      display.textContent = "";
      display.removeAttribute("data-result");
      display.removeAttribute("data-type");
      setExplanationDefault(); // è®¾ç½®ä¸ºé»˜è®¤çŠ¶æ€
      updateEstimateButtonState(); // æ›´æ–°æŒ‰é”®çŠ¶æ€
    }
    
    function backspace() {
      exprString = exprString.slice(0, -1);
      display.innerHTML = '<span class="inputExpr">' + formatExpression(exprString) + '</span>';
      
      // ä¿®æ”¹ï¼šæ ¹æ®è¡¨è¾¾å¼å†…å®¹æ›´æ–°è§£é‡ŠåŒº
      if (exprString.trim() === "") {
        setExplanationDefault();
      } else {
        explanationDiv.className = "explanation has-content";
        explanationDiv.textContent = exprString;
      }
      
      updateEstimateButtonState(); // æ›´æ–°æŒ‰é”®çŠ¶æ€
    }
    
    // ç²¾ç¡®è®¡ç®—ï¼Œä¿ç•™åŸè¡¨è¾¾å¼ç”¨äºåç»­ä¼°ç®—
    function calculate() {
      try {
        let expr = exprString.replace(/Ã·/g, '/')
                             .replace(/Ã—/g, '*')
                             .replace(/\^/g, '**');
        let result = eval(expr);
        let resultStr = String(result);
        display.innerHTML = `<span class="primaryAns">${resultStr}</span>`;
        setExplanationContent('è®¡ç®—ç»“æœä¸ºï¼š' + resultStr);
        display.setAttribute("data-result", "true");
        display.setAttribute("data-type", "calc");
        adjustAnswerDisplay();
        lastExpression = exprString;
        updateEstimateButtonState(); // æ›´æ–°æŒ‰é”®çŠ¶æ€
      } catch (error) {
        display.innerHTML = '<span style="font-size:60%;">é”™è¯¯</span>';
        setExplanationContent('');
        display.setAttribute("data-result", "true");
        display.setAttribute("data-type", "calc");
        updateEstimateButtonState(); // æ›´æ–°æŒ‰é”®çŠ¶æ€
      }
    }
    
    // çº¦ç­‰äºè®¡ç®—ï¼ˆé™¤æ³•ï¼‰
    function approximateCalculate(expr) {
      expr = expr.replace(/\s/g, '');
      const pattern = /^(-?\d+(?:\.\d+)?)([Ã·/])(-?\d+(?:\.\d+)?)$/;
      const match = expr.match(pattern);
      if (!match) return;
      let dividend = parseFloat(match[1]);
      let operator = match[2];
      let divisor = parseFloat(match[3]);
      if ((operator !== 'Ã·' && operator !== '/') || divisor === 0) return;
      
      const exact = dividend / divisor;
      const exactStr = exact.toFixed(2);

      // åŸºç¡€å€™é€‰è®¡ç®—
      const qRound = Math.round(dividend / divisor);
      const adjustedDividend = qRound * divisor;
      const estimatedStandard = qRound;
      let errorStandard = Math.abs(estimatedStandard - exact);
      errorStandard = Math.round(errorStandard * 10) / 10;
      const descStandard = `å°† ${dividend} è°ƒæ•´ä¸º ${adjustedDividend}ï¼ˆ${adjustedDividend} æ˜¯è·ç¦» ${dividend} æœ€è¿‘ä¸”ä¸º ${divisor} çš„å€æ•°ï¼‰ï¼Œç®—å¼å˜ä¸º ${adjustedDividend} Ã· ${divisor} = ${estimatedStandard}`;

      const estimatedSpecial = Math.floor(exact);
      let errorSpecial = Math.abs(estimatedSpecial - exact);
      errorSpecial = Math.round(errorSpecial * 10) / 10;
      const descSpecial = `ç›´æ¥èˆå» ${dividend} Ã· ${divisor} è®¡ç®—ç»“æœçš„å°æ•°éƒ¨åˆ†ï¼Œæœ€ç»ˆç®—å¼ï¼š${dividend} Ã· ${divisor} = ${estimatedSpecial}`;

      const dividendStr = String(Math.floor(dividend));
      const factorLeading = Math.pow(10, dividendStr.length - 1);
      const baseCandidateLeading = Math.floor(dividend / factorLeading) * factorLeading;
      const estimatedLeading = Math.round(baseCandidateLeading / divisor);
      let errorLeading = Math.abs(estimatedLeading - exact);
      errorLeading = Math.round(errorLeading * 10) / 10;
      const descLeading = `åªè€ƒè™‘è¢«é™¤æ•°çš„é¦–ä½æ•°å­—ï¼Œå³æå– ${Math.floor(dividend / factorLeading)} å¾—åˆ°åŸºæ•° ${baseCandidateLeading}ï¼Œç®—å¼å˜ä¸º ${baseCandidateLeading} Ã· ${divisor} = ${estimatedLeading}`;

      let baseCandidates = [
        {
          method: "æœ€å°è°ƒæ•´æ³•",
          candidate: estimatedStandard,
          error: errorStandard,
          desc: descStandard,
          priority: 1
        }
      ];

      // åªæœ‰åœ¨è¢«é™¤æ•°é™¤ä»¥é™¤æ•°ä¸æ˜¯æ•´æ•°æ—¶ï¼Œæ‰æ·»åŠ èˆä½™æ•°æ³•
      if (!Number.isInteger(dividend / divisor)) {
        baseCandidates.push({
          method: "èˆä½™æ•°æ³•",
          candidate: estimatedSpecial,
          error: errorSpecial,
          desc: descSpecial,
          priority: 3
        });
      }

      baseCandidates.push({
        method: "é¦–ä½ä¼°ç®—æ³•",
        candidate: estimatedLeading,
        error: errorLeading,
        desc: descLeading,
        priority: 4
      });

      // æ•´åæ•°æ³•å€™é€‰
      let roundedCandidates = [];
      const digits = dividendStr.length;
      if (digits <= 3) {
        const factor = 10;
        const roundedDividend = Math.floor(dividend / factor) * factor;
        const estimatedRounded = Math.round(roundedDividend / divisor);
        const errorRounded = Math.round(Math.abs(estimatedRounded - exact) * 10) / 10;
        const descRounded = `å°† ${dividend} æŒ‰å› å­ ${factor} èˆå…¥ï¼Œå¾—åˆ° ${roundedDividend}ï¼Œç®—å¼å˜ä¸º ${roundedDividend} Ã· ${divisor} = ${estimatedRounded}`;
        roundedCandidates.push({
          method: "æ•´åæ•°æ³•",
          candidate: estimatedRounded,
          error: errorRounded,
          desc: descRounded,
          priority: 2
        });
      } else if (digits === 4) {
        const factor1 = 10;
        const factor2 = 100; 
        const roundedDividend1 = Math.floor(dividend / factor1) * factor1;
        const roundedDividend2 = Math.floor(dividend / factor2) * factor2;    
        const estimatedRounded1 = Math.round(roundedDividend1 / divisor);
        const estimatedRounded2 = Math.round(roundedDividend2 / divisor);    
        const errorRounded1 = Math.abs(estimatedRounded1 - exact);
        const errorRounded2 = Math.abs(estimatedRounded2 - exact);    
        if (errorRounded1 <= errorRounded2) {
          roundedCandidates.push({
            method: "æ•´åæ•°æ³•",
            candidate: estimatedRounded1,
            error: Math.round(errorRounded1 * 10) / 10,
            desc: `å°† ${dividend} æŒ‰å› å­ ${factor1} èˆå…¥ï¼Œå¾—åˆ° ${roundedDividend1}ï¼Œç®—å¼å˜ä¸º ${roundedDividend1} Ã· ${divisor} = ${estimatedRounded1}`
          });
        } else {
          roundedCandidates.push({
            method: "æ•´åæ•°æ³•",
            candidate: estimatedRounded2,
            error: Math.round(errorRounded2 * 10) / 10,
            desc: `å°† ${dividend} æŒ‰å› å­ ${factor2} èˆå…¥ï¼Œå¾—åˆ° ${roundedDividend2}ï¼Œç®—å¼å˜ä¸º ${roundedDividend2} Ã· ${divisor} = ${estimatedRounded2}`
          });
        }
      } else {
        const factor1 = Math.pow(10, digits - 1);
        const factor2 = Math.pow(10, digits - 2);
        const factor3 = Math.pow(10, digits - 3);
        
        let arr = [
          { 
            factor: factor1, 
            candidate: Math.round((Math.floor(dividend / factor1) * factor1) / divisor),
            error: Math.abs(Math.round((Math.floor(dividend / factor1) * factor1) / divisor) - exact)
          },
          { 
            factor: factor2, 
            candidate: Math.round((Math.floor(dividend / factor2) * factor2) / divisor),
            error: Math.abs(Math.round((Math.floor(dividend / factor2) * factor2) / divisor) - exact)
          },
          { 
            factor: factor3, 
            candidate: Math.round((Math.floor(dividend / factor3) * factor3) / divisor),
            error: Math.abs(Math.round((Math.floor(dividend / factor3) * factor3) / divisor) - exact)
          }
        ];
        
        arr.sort((a, b) => a.error - b.error);
        const best = arr[0];
        const roundedDividend = Math.floor(dividend / best.factor) * best.factor;
        
        roundedCandidates.push({
          method: "æ•´åæ•°æ³•",
          candidate: best.candidate,
          error: Math.round(best.error * 10) / 10,
          desc: `å°† ${dividend} æŒ‰å› å­ ${best.factor} èˆå…¥ï¼Œå¾—åˆ° ${roundedDividend}ï¼Œç®—å¼å˜ä¸º ${roundedDividend} Ã· ${divisor} = ${best.candidate}`,
          priority: 2
        });
      }

      baseCandidates = baseCandidates.concat(roundedCandidates);

      // æ¬¡ä½å–æ•´æ³•å€™é€‰ï¼ˆä»…å½“è¢«é™¤æ•° > 100 æ—¶æ¿€æ´»ï¼‰
      if (dividend > 100) {
        // å®šä¹‰æ¬¡ä½èˆå…¥å‡½æ•°
        function secondDigitRoundDown(num) {
          if (num < 10) return num;
          if (num < 100) return Math.floor(num / 10) * 10;
          let d = Math.floor(Math.log10(num)) + 1;
          let factor = Math.pow(10, d - 2);
          return Math.floor(num / factor) * factor;
        }
        function secondDigitRoundUp(num) {
          if (num < 10) return num;
          if (num < 100) return Math.ceil(num / 10) * 10;
          let d = Math.floor(Math.log10(num)) + 1;
          let factor = Math.pow(10, d - 2);
          return Math.ceil(num / factor) * factor;
        }

        let s1_dividend = secondDigitRoundDown(dividend);
        let s1_divisor = secondDigitRoundDown(divisor);
        let candidate1 = Math.floor(s1_dividend / s1_divisor);
        let error1 = Math.round(Math.abs(candidate1 - exact) * 10) / 10;
        let desc1 = `æ¬¡ä½å–æ•´æ³•1ï¼šé‡‡ç”¨å‡å‘ä¸‹èˆå…¥ç­–ç•¥ï¼Œæœ€ç»ˆç®—å¼ï¼š${s1_dividend} Ã· ${s1_divisor} = ${candidate1}`;

        let s2a_dividend = secondDigitRoundUp(dividend);
        let s2a_divisor = secondDigitRoundDown(divisor);
        let candidate2_A = Math.floor(s2a_dividend / s2a_divisor);
        let error2_A = Math.abs(candidate2_A - exact);

        let s2b_dividend = secondDigitRoundDown(dividend);
        let s2b_divisor = secondDigitRoundUp(divisor);
        let candidate2_B = Math.floor(s2b_dividend / s2b_divisor);
        let error2_B = Math.abs(candidate2_B - exact);

        let candidate2, error2, desc2;
        if (error2_A <= error2_B) {
          candidate2 = candidate2_A;
          error2 = Math.round(error2_A * 10) / 10;
          desc2 = `æ¬¡ä½å–æ•´æ³•2ï¼šé‡‡ç”¨è¢«é™¤æ•°å‘ä¸Šèˆã€é™¤æ•°å‘ä¸‹èˆï¼Œç®—å¼ï¼š${s2a_dividend} Ã· ${s2a_divisor} = ${candidate2}`;
        } else {
          candidate2 = candidate2_B;
          error2 = Math.round(error2_B * 10) / 10;
          desc2 = `æ¬¡ä½å–æ•´æ³•2ï¼šé‡‡ç”¨è¢«é™¤æ•°å‘ä¸‹èˆã€é™¤æ•°å‘ä¸Šèˆï¼Œç®—å¼ï¼š${s2b_dividend} Ã· ${s2b_divisor} = ${candidate2}`;
        }

        let s3_dividend = secondDigitRoundUp(dividend);
        let s3_divisor = secondDigitRoundUp(divisor);
        let candidate3 = Math.floor(s3_dividend / s3_divisor);
        let error3 = Math.round(Math.abs(candidate3 - exact) * 10) / 10;
        let desc3 = `æ¬¡ä½å–æ•´æ³•3ï¼šé‡‡ç”¨å‡å‘ä¸Šèˆå…¥ç­–ç•¥ï¼Œç®—å¼ï¼š${s3_dividend} Ã· ${s3_divisor} = ${candidate3}`;

        let arr = [
          { candidate: candidate1, error: error1, desc: desc1 },
          { candidate: candidate2, error: error2, desc: desc2 },
          { candidate: candidate3, error: error3, desc: desc3 }
        ];

        // å½“é™¤æ•° <100 æ—¶çš„å››ç§å€™é€‰
        if (divisor < 100) {
          let divisorDown = secondDigitRoundDown(divisor) || 1;
          let candidateDivDown = Math.floor(dividend / divisorDown);
          let errorDivDown = Math.abs(candidateDivDown - exact);
          let descDivDown = `æ¬¡ä½å•è°ƒæ•´ï¼šè¢«é™¤æ•°ä¿æŒ ${dividend}ï¼Œé™¤æ•°å‘ä¸‹è°ƒæ•´ä¸º ${divisorDown}ï¼Œç®—å¼å˜ä¸º ${dividend} Ã· ${divisorDown} = ${candidateDivDown}`;

          let divisorUp = secondDigitRoundUp(divisor);
          let candidateDivUp = Math.floor(dividend / divisorUp);
          let errorDivUp = Math.abs(candidateDivUp - exact);
          let descDivUp = `æ¬¡ä½å–æ•´æ³•æ–°å¢ï¼šè¢«é™¤æ•°ä¿æŒ ${dividend}ï¼Œé™¤æ•°å‘ä¸Šè°ƒæ•´ä¸º ${divisorUp}ï¼Œç®—å¼å˜ä¸º ${dividend} Ã· ${divisorUp} = ${candidateDivUp}`;

          let dividendDown = secondDigitRoundDown(dividend);
          let candidateDividendDown = Math.floor(dividendDown / divisor);
          let errorDividendDown = Math.abs(candidateDividendDown - exact);
          let descDividendDown = `æ¬¡ä½å•è°ƒæ•´ï¼šé™¤æ•°ä¿æŒ ${divisor}ï¼Œè¢«é™¤æ•°å‘ä¸‹è°ƒæ•´ä¸º ${dividendDown}ï¼Œç®—å¼å˜ä¸º ${dividendDown} Ã· ${divisor} = ${candidateDividendDown}`;

          let dividendUp = secondDigitRoundUp(dividend);
          let candidateDividendUp = Math.floor(dividendUp / divisor);
          let errorDividendUp = Math.abs(candidateDividendUp - exact);
          let descDividendUp = `æ¬¡ä½å•è°ƒæ•´ï¼šé™¤æ•°ä¿æŒ ${divisor}ï¼Œè¢«é™¤æ•°å‘ä¸Šè°ƒæ•´ä¸º ${dividendUp}ï¼Œç®—å¼å˜ä¸º ${dividendUp} Ã· ${divisor} = ${candidateDividendUp}`;

          let newCandidates = [
            { candidate: candidateDivDown, error: errorDivDown, desc: descDivDown },
            { candidate: candidateDivUp, error: errorDivUp, desc: descDivUp },
            { candidate: candidateDividendDown, error: errorDividendDown, desc: descDividendDown },
            { candidate: candidateDividendUp, error: errorDividendUp, desc: descDividendUp }
          ];

          newCandidates.sort((a, b) => a.error - b.error);
          
          // ç‰¹å¾æ’åºé€»è¾‘
          const dividendDigits = dividend === 0 ? 1 : String(Math.floor(Math.abs(dividend))).length;
          const threshold = dividendDigits;
          const hasEnoughCandidates = newCandidates.length >= 2;
          let topCandidates = hasEnoughCandidates ? [newCandidates[0], newCandidates[1]] : [...newCandidates];
          const otherCandidates = hasEnoughCandidates ? newCandidates.slice(2) : [];

          if (hasEnoughCandidates) {
            const errorDiff = topCandidates[1].error - topCandidates[0].error;
            if (errorDiff <= threshold) {
              topCandidates.forEach(c => {
                c.features = getTrailingFeatures(c.candidate);
              });

              topCandidates.sort((a, b) => {
                const zeroDiff = b.features.trailingZeros - a.features.trailingZeros;
                if (zeroDiff !== 0) return zeroDiff;
                
                const countDiff = b.features.zeroAndFiveCount - a.features.zeroAndFiveCount;
                if (countDiff !== 0) return countDiff;
                
                return a.error - b.error;
              });
            }
          }

          newCandidates = [...topCandidates, ...otherCandidates];
          arr.push(newCandidates[0]);
        }

        arr.sort((a, b) => a.error - b.error);
        let A_val = arr[0].candidate;
        let errorA_new = arr[0].error;
        let descA_new = arr[0].desc;

        let subCandidates = [];
        subCandidates.push({
          method: "æ¬¡ä½å–æ•´æ³•",
          subMethod: "A",
          candidate: A_val,
          error: errorA_new,
          desc: descA_new
        });

        // B å’Œ C çš„ç”Ÿæˆé€»è¾‘
        let B, C;
        if (A_val > 10) {
          let digitsA = Math.floor(Math.log10(A_val)) + 1;
          let factor = Math.pow(10, digitsA - 1);
          B = Math.round(A_val / factor) * factor;
        }
        if (A_val > 100) {
          let digitsA = Math.floor(Math.log10(A_val)) + 1;
          let factorC = Math.pow(10, digitsA - 2);
          C = Math.round(A_val / factorC) * factorC;
        }

        if (typeof B !== "undefined" && Math.floor(B) !== Math.floor(A_val)) {
          subCandidates.push({
            method: "æ¬¡ä½å–æ•´æ³•",
            subMethod: "B",
            candidate: B,
            error: Math.round(Math.abs(B - exact) * 10) / 10,
            desc: `æ ¹æ® A ç”Ÿæˆ Bï¼šA=${descA_new}ï¼Œå–æœ€é«˜ä½åå¾—åˆ° B=${B}`
          });
        }
        if (typeof C !== "undefined" && Math.floor(C) !== Math.floor(A_val)) {
          subCandidates.push({
            method: "æ¬¡ä½å–æ•´æ³•",
            subMethod: "C",
            candidate: C,
            error: Math.round(Math.abs(C - exact) * 10) / 10,
            desc: `æ ¹æ® A ç”Ÿæˆ Cï¼šA=${descA_new}ï¼Œå–å‰ä¸¤ä½åå¾—åˆ° C=${C}`
          });
        }

        // D çš„ç”Ÿæˆé€»è¾‘
        let newDiv1 = secondDigitRoundDown(dividend);
        let newDivisor1 = secondDigitRoundDown(divisor);
        let candidate_D1 = Math.floor(newDiv1 / newDivisor1);
        let change1_val = Math.abs(dividend - newDiv1) + Math.abs(divisor - newDivisor1);

        let newDiv2 = secondDigitRoundUp(dividend);
        let newDivisor2 = secondDigitRoundDown(divisor);
        let candidate_D2 = Math.floor(newDiv2 / newDivisor2);
        let change2_val = Math.abs(dividend - newDiv2) + Math.abs(divisor - newDivisor2);

        let newDiv3 = secondDigitRoundDown(dividend);
        let newDivisor3 = secondDigitRoundUp(divisor);
        let candidate_D3 = Math.floor(newDiv3 / newDivisor3);
        let change3_val = Math.abs(dividend - newDiv3) + Math.abs(divisor - newDivisor3);

        let newDiv4 = secondDigitRoundUp(dividend);
        let newDivisor4 = secondDigitRoundUp(divisor);
        let candidate_D4 = Math.floor(newDiv4 / newDivisor4);
        let change4_val = Math.abs(dividend - newDiv4) + Math.abs(divisor - newDivisor4);

        let changes = [
          { candidate: candidate_D1, change: change1_val, newDiv: newDiv1, newDivisor: newDivisor1 },
          { candidate: candidate_D2, change: change2_val, newDiv: newDiv2, newDivisor: newDivisor2 },
          { candidate: candidate_D3, change: change3_val, newDiv: newDiv3, newDivisor: newDivisor3 },
          { candidate: candidate_D4, change: change4_val, newDiv: newDiv4, newDivisor: newDivisor4 }
        ];

        changes.sort((a, b) => a.change - b.change);
        let bestChange = changes[0];
        let D = bestChange.candidate;
        let errorD = Math.round(Math.abs(D - exact) * 10) / 10;
        let descD = `æ¬¡ä½æœ€å°è°ƒæ•´ï¼šé€‰å–å˜åŒ–é‡æœ€å°çš„æ–¹æ¡ˆï¼Œç®—å¼ï¼š${bestChange.newDiv} Ã· ${bestChange.newDivisor} = ${D}ï¼Œå˜åŒ–é‡ ${bestChange.change}`;

        let dCandidate = null;
        if (Math.floor(D) !== Math.floor(A_val)) {
          dCandidate = {
            method: "æ¬¡ä½å–æ•´æ³•",
            subMethod: "D",
            candidate: D,
            error: errorD,
            desc: descD
          };
        }

        baseCandidates = baseCandidates.concat(subCandidates);

        if (dCandidate) {
          let idxA = baseCandidates.findIndex(item => 
            item.method === "æ¬¡ä½å–æ•´æ³•" && item.subMethod === "A"
          );
          
          if (idxA !== -1) {
            let errorDiff = Math.abs(dCandidate.error - baseCandidates[idxA].error);
            let digitThreshold = String(Math.floor(Math.abs(dividend))).length - 1;
            
            if (errorDiff <= digitThreshold) {
              baseCandidates.splice(idxA, 0, dCandidate);
            } else {
              let minIndex = baseCandidates.findIndex(item => item.method === "æœ€å°è°ƒæ•´æ³•");
              if (minIndex >= 0) {
                if (dCandidate.error < baseCandidates[minIndex].error) {
                  baseCandidates.splice(minIndex, 0, dCandidate);
                } else {
                  baseCandidates.splice(minIndex + 1, 0, dCandidate);
                }
              } else {
                baseCandidates.push(dCandidate);
              }
            }
          }
        }

        // å½“è¢«é™¤æ•°å°äº100æ—¶çš„ç‰¹æ®Šæ’åºè§„åˆ™
        if (Math.abs(dividend) < 100) {
          baseCandidates.sort((a, b) => {
            if (a.method === "æœ€å°è°ƒæ•´æ³•") return -1;
            if (b.method === "æœ€å°è°ƒæ•´æ³•") return 1;
            return a.error - b.error;
          });
        } else {
          baseCandidates.sort((a, b) => a.error - b.error);
        }
      }

      // åº”ç”¨åç½®æ’åºè§„åˆ™
      baseCandidates = applyPostSortRules(baseCandidates, dividend, divisor);

      // è°ƒç”¨ç»Ÿä¸€ç»“æœå¤„ç†
      const results = processResults(baseCandidates, exact);
      let primaryResult = results.primary;
      let secondaryResult = results.secondary;

      // å°¾éƒ¨é›¶æ•°é‡æ£€æŸ¥å¹¶äº¤æ¢
      function countTrailingZeros(num) {
        let s = String(Math.floor(num));
        let m = s.match(/0+$/);
        return m ? m[0].length : 0;
      }
      if (
        secondaryResult &&
        countTrailingZeros(secondaryResult) > countTrailingZeros(primaryResult)
      ) {
        let temp = primaryResult;
        primaryResult = secondaryResult;
        secondaryResult = temp;
      }

      // ç”Ÿæˆè§£é‡Šå­—ç¬¦ä¸²
      let explanationStr = `åŸç®—å¼ï¼š${dividend} Ã· ${divisor} = ${exactStr}\n`;
      let candidateCount = {};
      let displayLimit = 2;

      baseCandidates.forEach(item => {
        let key = String(Math.floor(item.candidate));
        if (!candidateCount[key]) {
          candidateCount[key] = 0;
        }
        if (candidateCount[key] >= displayLimit) return;
        explanationStr += `ã€${item.method}ã€‘ ${item.desc}ï¼Œä¼°å€¼ä¸º <strong style="font-size:1.1em;">${item.candidate}</strong>ï¼ˆè¯¯å·®: ${item.error.toFixed(1)}ï¼‰\n`;
        candidateCount[key]++;
      });

      // ä¿®å¤ï¼šæ£€æŸ¥æ¬¡é€‰ç»“æœæ˜¯å¦ä¸ºç©º
      let displayHTML;
      if (secondaryResult && secondaryResult !== "") {
        displayHTML = `<span class="primaryAns"><span class="estimatePrefix">â‰ˆ </span>${primaryResult}</span>
          <span class="separator">/</span>
          <span class="secondaryContainer">
            <span class="secondaryLabel">æ¬¡é€‰</span>
            <span class="secondaryAns">${secondaryResult}</span>
          </span>`;
      } else {
        displayHTML = `<span class="primaryAns"><span class="estimatePrefix">â‰ˆ </span>${primaryResult}</span>`;
      }

      display.innerHTML = displayHTML;
      display.setAttribute("data-result", "true");
      display.setAttribute("data-type", "estimate");
      setExplanationContent(explanationStr);
      adjustAnswerDisplay();
      updateEstimateButtonState(); // æ›´æ–°æŒ‰é”®çŠ¶æ€
    }

    // åç½®æ’åºè§„åˆ™å‡½æ•°
    function applyPostSortRules(baseCandidates, dividend, divisor) {
      let digitCount = String(Math.floor(Math.abs(dividend))).length;
      
      baseCandidates.sort((a, b) => a.error - b.error);

      let ciweiMethods = baseCandidates.filter(item => 
        item.method === "æ¬¡ä½å–æ•´æ³•" && 
        (item.subMethod === "A" || item.subMethod === "D")
      );
      
      if (ciweiMethods.length > 0) {
        let bestCiwei = ciweiMethods.reduce((a, b) => 
          a.error <= b.error ? a : b
        );
        
        if (bestCiwei.error <= 1) {
          let currentIdx = baseCandidates.findIndex(item => 
            item.method === bestCiwei.method && 
            item.subMethod === bestCiwei.subMethod
          );
          if (currentIdx > 0) {
            baseCandidates.splice(currentIdx, 1);
            baseCandidates.unshift(bestCiwei);
          }
        }
      }
      
      if (digitCount <= 3) {
        let idxMinAdjust = baseCandidates.findIndex(item => item.method === "æœ€å°è°ƒæ•´æ³•");
        let idxLeading = baseCandidates.findIndex(item => item.method === "é¦–ä½ä¼°ç®—æ³•");
        if (idxMinAdjust !== -1 && idxLeading !== -1 && idxMinAdjust > idxLeading) {
          let temp = baseCandidates[idxMinAdjust];
          baseCandidates.splice(idxMinAdjust, 1);
          baseCandidates.splice(idxLeading, 0, temp);
        }
      }

      if (dividend > 100) {
        let idxLeading = baseCandidates.findIndex(item => item.method === "é¦–ä½ä¼°ç®—æ³•");
        let idxCiweiA = baseCandidates.findIndex(item => 
          item.method === "æ¬¡ä½å–æ•´æ³•" && item.subMethod === "A"
        );
        let idxCiweiD = baseCandidates.findIndex(item => 
          item.method === "æ¬¡ä½å–æ•´æ³•" && item.subMethod === "D"
        );

        if (idxCiweiA !== -1 && idxCiweiD !== -1) {
          let errorA = baseCandidates[idxCiweiA].error;
          let errorD = baseCandidates[idxCiweiD].error;
          let bestCiweiIdx = errorA <= errorD ? idxCiweiA : idxCiweiD;
          
          if (idxLeading !== -1) {
            let bestCiwei = baseCandidates[bestCiweiIdx];
            baseCandidates.splice(bestCiweiIdx, 1);
            baseCandidates.splice(idxLeading, 0, bestCiwei);
          }
        }
      }

      return baseCandidates;
    }
    
    // åŠ å‡æ³•å’Œä¹˜æ³•ä¼°ç®—å‡½æ•°
    function approximateCalculateOther(expr) {
      expr = expr.replace(/\s/g, '');
      const pattern = /^(-?\d+(?:\.\d+)?)([+\-Ã—])(-?\d+(?:\.\d+)?)$/;
      const match = expr.match(pattern);
      if (!match) return;
      let a = parseFloat(match[1]);
      let op = match[2];
      let b = parseFloat(match[3]);
      let precise;
      if (op === '+') precise = a + b;
      else if (op === '-') precise = a - b;
      else if (op === 'Ã—') {
        // ä¿®å¤ï¼šæ­£ç¡®è°ƒç”¨ä¹˜æ³•ä¼°ç®—å‡½æ•°
        estimateMultiplication(a, b);
        return;
      }

      let candidates = [];

      // ä¸“é—¨è§„åˆ™ï¼ˆåŸç‰¹æ®Šè§„åˆ™ï¼‰
      candidates.push({
        method: "ä¸“é—¨è§„åˆ™",
        candidate: specialResultRound(precise),
        error: 0,
        desc: `å½“ç»“æœè¾ƒå°æ—¶é‡‡ç”¨ç‰¹æ®Šå››èˆäº”å…¥æ³•ï¼Œæœ€ç»ˆç®—å¼ï¼š${a} ${op} ${b} = ${precise} â†’ ${specialResultRound(precise)}`
      });

      // åŸå§‹åˆ†åˆ«å››èˆäº”å…¥
      let roundedA = Math.round(a / 10) * 10;
      let roundedB = Math.round(b / 10) * 10;
      candidates.push({
        method: "åˆ†åˆ«å››èˆäº”å…¥",
        candidate: op === "+" ? roundedA + roundedB : roundedA - roundedB,
        error: 0,
        desc: `åˆ†åˆ«å°†ä¸¤ä¸ªæ•°å‘æœ€è¿‘10èˆå…¥åè®¡ç®—ï¼Œæœ€ç»ˆç®—å¼ï¼š${roundedA} ${op} ${roundedB} = ${op === "+" ? roundedA + roundedB : roundedA - roundedB}`
      });

      // åˆ†åˆ«å››èˆäº”å…¥çš„ä¸¤ç§æ–°æƒ…å½¢ï¼ˆä»…å‡æ³•ï¼‰
      if (op === "-") {
        let case1 = {
          candidate: roundedA - b,
          error: Math.abs((roundedA - b) - precise),
          desc: `è¢«å‡æ•°å››èˆäº”å…¥ï¼š${roundedA} - ${b} = ${roundedA - b}`
        };
        
        let case2 = {
          candidate: a - roundedB,
          error: Math.abs((a - roundedB) - precise),
          desc: `å‡æ•°å››èˆäº”å…¥ï¼š${a} - ${roundedB} = ${a - roundedB}`
        };

        let betterCase = case1.error <= case2.error ? case1 : case2;
        candidates.push({
          method: "åˆ†åˆ«å››èˆäº”å…¥2",
          candidate: betterCase.candidate,
          error: betterCase.error,
          desc: betterCase.desc
        });
      }

      // é¦–ä½ä¼°ç®—æ³•
      let msdA = floorToMSD(a);
      let msdB = floorToMSD(b);
      candidates.push({
        method: "é¦–ä½ä¼°ç®—æ³•",
        candidate: op === "+" ? msdA + msdB : msdA - msdB,
        error: 0,
        desc: `å–ä¸¤ä¸ªæ•°çš„é¦–ä½ä¼°ç®—ç›´æ¥è®¡ç®—ï¼Œæœ€ç»ˆç®—å¼ï¼š${msdA} ${op} ${msdB} = ${op === "+" ? msdA + msdB : msdA - msdB}`,
        priority: 4
      });

      // é¦–ä½ä¼°ç®—çš„ä¸¤ç§æ–°æƒ…å½¢ï¼ˆä»…å‡æ³•ï¼‰
      if (op === "-") {
        let case1 = {
          candidate: msdA - b,
          error: Math.abs((msdA - b) - precise),
          desc: `è¢«å‡æ•°å–é¦–ä½ï¼š${msdA} - ${b} = ${msdA - b}`
        };
        
        let case2 = {
          candidate: a - msdB,
          error: Math.abs((a - msdB) - precise),
          desc: `å‡æ•°å–é¦–ä½ï¼š${a} - ${msdB} = ${a - msdB}`
        };

        let betterCase = case1.error <= case2.error ? case1 : case2;
        candidates.push({
          method: "é¦–ä½ä¼°ç®—æ³•2",
          candidate: betterCase.candidate,
          error: betterCase.error,
          desc: betterCase.desc
        });
      }

      // æ ‡å‡†è§„åˆ™
      let unit = getPrecision(precise) / 10;
      let candidate_standard = Math.round(precise / unit) * unit;
      candidates.push({
        method: "æ ‡å‡†è§„åˆ™",
        candidate: candidate_standard,
        error: 0,
        desc: `å°†ç²¾ç¡®ç»“æœå››èˆäº”å…¥è‡³æœ€è¿‘å•ä½å¾—åˆ°å€™é€‰å€¼ï¼Œæœ€ç»ˆç®—å¼ï¼šMath.round(${precise}/10)*10 = ${candidate_standard}`,
        priority: 0
      });

      // æ¬¡ä½ä¼°ç®—æ³•ï¼ˆå½“ä»»ä¸€æ•° >= 100 æ—¶ï¼‰
      if ((a >= 100 || b >= 100) && (op === "-" || op === "+")) {
        // é€šç”¨å–æ•´å‡½æ•°
        function getSmartRounds(num) {
          let absNum = Math.abs(num);
          let str = String(Math.floor(absNum));
          
          if (absNum >= 100) {
            let keepDigits = Math.min(2, str.length);
            let factor = Math.pow(10, str.length - keepDigits);
            let base = parseInt(str.substr(0, keepDigits)) * factor;
            
            return [
              base - factor,
              base,
              base + factor
            ].filter(v => v > 0);
          } else {
            let firstDigit = parseInt(str[0]) || 0;
            return [
              (firstDigit - 1) * 10,
              firstDigit * 10,
              (firstDigit + 1) * 10
            ].filter(v => v >= 0);
          }
        }

        // æ¬¡ä½ä¼°ç®—æ³•1ï¼ˆæ··åˆå–æ•´ï¼‰
        let aRounds = getSmartRounds(a);
        let bRounds = getSmartRounds(b);
        let combinations = [];
        let exactRounded = Math.round(precise / 10) * 10;

        aRounds.forEach(aVal => {
          bRounds.forEach(bVal => {
            if (aVal === a && bVal === b) return;
            let calc = op === "+" ? aVal + bVal : aVal - bVal;
            combinations.push({
              result: calc,
              error: Math.abs(calc - exactRounded),
              desc: `${a}â†’${aVal}, ${b}â†’${bVal}, è®¡ç®— ${aVal} ${op} ${bVal} = ${calc}`,
              aChange: Math.abs(aVal - a),
              bChange: Math.abs(bVal - b)
            });
          });
        });

        if (combinations.length > 0) {
          combinations.sort((a, b) => {
            if (a.error === b.error) {
              return (a.aChange + a.bChange) - (b.aChange + b.bChange);
            }
            return a.error - b.error;
          });

          let zeroError = combinations.filter(c => c.error === 0);
          let otherError = combinations.filter(c => c.error > 0);
          let uniqueResults = [];
          
          zeroError.slice(0, 1).forEach(item => {
            if (!uniqueResults.some(x => Math.floor(x.result) === Math.floor(item.result))) {
              uniqueResults.push(item);
            }
          });

          if (zeroError.length > 0 && otherError.length > 0) {
            let bestNonZero = otherError[0];
            if (!uniqueResults.some(x => Math.abs(x.result - bestNonZero.result) <= 10)) {
              uniqueResults.push(bestNonZero);
            }
          }

          let existingIntegersFeature = candidates.map(c => Math.floor(c.candidate));
          combinations.forEach(item => {
            let features = getTrailingFeatures(item.result);
            let lastDigit = Math.abs(item.result) % 10;
            let integerPart = Math.floor(item.result);
            
            if (lastDigit === 0 && features.trailingZeros >= 1) {
              if (existingIntegersFeature.indexOf(integerPart) === -1) {
                uniqueResults.push(Object.assign({}, item));
                existingIntegersFeature.push(integerPart);
              }
            } else if (lastDigit === 5 && features.zeroAndFiveCount >= 2) {
              if (existingIntegersFeature.indexOf(integerPart) === -1) {
                uniqueResults.push(Object.assign({}, item));
                existingIntegersFeature.push(integerPart);
              }
            }
          });

          uniqueResults.slice(0, 3).forEach((item, index) => {
            candidates.push({
              method: `æ¬¡ä½ä¼°ç®—æ³•1-${index + 1}`,
              candidate: item.result,
              error: item.error,
              desc: item.desc
            });
          });
        }
      }

      // æ•´åæ•°æ³•
      function getRoundedCandidatesForAddSub(num) {
        let absNum = Math.abs(num);
        let digitCount = String(Math.floor(absNum)).length;
        let results = [];
        
        function addCandidate(factor) {
          let candidateDown = Math.floor(num / factor) * factor;
          let candidateUp = Math.ceil(num / factor) * factor;
          if (candidateDown !== 0) results.push(candidateDown);
          if (candidateUp !== 0 && candidateUp !== candidateDown) results.push(candidateUp);
        }

        if (digitCount === 1) {
          addCandidate(10);
        } else if (digitCount <= 3) {
          addCandidate(10);
          if (absNum >= 100) {
            addCandidate(100);
          }
        } else if (digitCount === 4) {
          addCandidate(100);
        } else {
          addCandidate(Math.pow(10, digitCount - 1));
          addCandidate(Math.pow(10, digitCount - 2));
          addCandidate(Math.pow(10, digitCount - 3));
        }
        
        return Array.from(new Set(results));
      }

      let candidatesA = getRoundedCandidatesForAddSub(a);
      let candidatesB = getRoundedCandidatesForAddSub(b);
      let allCombinations = [];

      for (let i = 0; i < candidatesA.length; i++) {
        for (let j = 0; j < candidatesB.length; j++) {
          let calc = op === "+" ? candidatesA[i] + candidatesB[j] : candidatesA[i] - candidatesB[j];
          let err = Math.abs(calc - precise);
          let changeSum = Math.abs(candidatesA[i] - a) + Math.abs(candidatesB[j] - b);
          
          allCombinations.push({
            result: calc,
            error: err,
            changeSum: changeSum,
            desc: `å°† ${a} å˜ä¸º ${candidatesA[i]}ï¼Œ${b} å˜ä¸º ${candidatesB[j]}ï¼Œå¾—åˆ° ${candidatesA[i]} ${op} ${candidatesB[j]} = ${calc}`
          });
        }
      }

      // æ•´åæ•°æ³•3ï¼ˆä»…å˜åŒ–å•ä¸ªå€¼çš„æƒ…å½¢ï¼Œä»…å‡æ³•ï¼‰
      if (op === "-") {
        let singleChangeCombos = allCombinations.filter(combo => {
          let aChanged = combo.desc.indexOf(`å°† ${a} å˜ä¸º`) !== -1 && combo.desc.indexOf(`${b} å˜ä¸º`) === -1;
          let bChanged = combo.desc.indexOf(`${b} å˜ä¸º`) !== -1 && combo.desc.indexOf(`å°† ${a} å˜ä¸º`) === -1;
          return aChanged || bChanged;
        });

        let sortedSingleChange = singleChangeCombos.sort((a, b) => {
          if (a.error === b.error) return a.changeSum - b.changeSum;
          return a.error - b.error;
        });

        let uniqueSingle = [];
        for (let k = 0; k < sortedSingleChange.length; k++) {
          let combo = sortedSingleChange[k];
          if (!uniqueSingle.some(x => Math.floor(x.result) === Math.floor(combo.result))) {
            uniqueSingle.push(combo);
            if (uniqueSingle.length >= 2) break;
          }
        }

        uniqueSingle.forEach((combo, index) => {
          candidates.push({
            method: `æ•´åæ•°æ³•${index + 3}`,
            candidate: combo.result,
            error: combo.error,
            desc: combo.desc + "ï¼ˆå•å€¼å˜åŒ–æ–¹æ¡ˆï¼‰"
          });
        });
      }

      allCombinations.sort((a, b) => {
        if (Math.abs(a.error - b.error) < 1e-10) {
          return a.changeSum - b.changeSum;
        }
        return a.error - b.error;
      });

      let uniqueCombinationResults = [];
      for (let l = 0; l < allCombinations.length; l++) {
        let combo = allCombinations[l];
        if (!uniqueCombinationResults.some(x => Math.floor(x.result) === Math.floor(combo.result))) {
          uniqueCombinationResults.push(combo);
        }
      }

      if (uniqueCombinationResults.length > 0) {
        candidates.push({
          method: "æ•´åæ•°æ³•1",
          candidate: uniqueCombinationResults[0].result,
          error: uniqueCombinationResults[0].error,
          desc: uniqueCombinationResults[0].desc
        });
      }
      if (uniqueCombinationResults.length > 1) {
        candidates.push({
          method: "æ•´åæ•°æ³•2",
          candidate: uniqueCombinationResults[1].result,
          error: uniqueCombinationResults[1].error,
          desc: uniqueCombinationResults[1].desc
        });
      }

      // è®¡ç®—è¯¯å·®å¹¶å»é‡
      candidates.forEach(item => {
        item.error = Math.round(Math.abs(item.candidate - precise) * 10) / 10;
      });

      let uniqueCandidates = [];
      candidates.forEach(item => {
        if (!uniqueCandidates.some(x => x.candidate === item.candidate)) {
          uniqueCandidates.push(item);
        }
      });
      candidates = uniqueCandidates;
      candidates.sort((a, b) => a.error - b.error);

      // å½“åŠ æ•°ä½æ•°å’Œå¤§äºç­‰äº5æ—¶çš„ç‰¹æ®Šæ’åº
      let digitSum = String(Math.floor(Math.abs(a))).length + String(Math.floor(Math.abs(b))).length;
      if (digitSum >= 5) {
        let idxLeading = candidates.findIndex(item => item.method === "é¦–ä½ä¼°ç®—æ³•");
        let idxZhengtenshu = candidates.findIndex(item => item.method.indexOf("æ•´åæ•°æ³•") !== -1);
        if (idxLeading !== -1 && idxZhengtenshu !== -1) {
          if (candidates[idxZhengtenshu].error <= candidates[idxLeading].error && idxZhengtenshu > idxLeading) {
            let temp = candidates[idxZhengtenshu];
            candidates.splice(idxZhengtenshu, 1);
            candidates.splice(idxLeading, 0, temp);
          }
        }
      }

      let results = processResults(candidates, precise);
      let primary = results.primary;
      let secondary = results.secondary;

      // æ£€æŸ¥å°¾éƒ¨é›¶æ•°é‡å¹¶äº¤æ¢
      function countTrailingZeros(num) {
        let s = String(Math.floor(num));
        let m = s.match(/0+$/);
        return m ? m[0].length : 0;
      }
      if (secondary && countTrailingZeros(secondary) > countTrailingZeros(primary)) {
        let temp = primary;
        primary = secondary;
        secondary = temp;
      }

      let explanationStr = `åŸç®—å¼ï¼š${a} ${op} ${b} = ${precise}\n`;
      let candidateCount = {};
      candidates.forEach(item => {
        let key = String(Math.floor(item.candidate));
        if (!candidateCount[key]) {
          candidateCount[key] = 0;
        }
        if (candidateCount[key] >= 2) return;
        explanationStr += `ã€${item.method}ã€‘ ${item.desc}ï¼Œä¼°å€¼ä¸º <strong style="font-size:1.1em;">${item.candidate}</strong>ï¼ˆè¯¯å·®: ${item.error.toFixed(1)}ï¼‰\n`;
        candidateCount[key]++;
      });

      // ä¿®å¤ï¼šæ£€æŸ¥æ¬¡é€‰ç»“æœæ˜¯å¦ä¸ºç©º
      let displayHTML;
      if (secondary && secondary !== "") {
        displayHTML = `<span class="primaryAns">â‰ˆ ${primary}</span>
           <span class="separator">/</span>
           <span class="secondaryContainer">
             <span class="secondaryLabel">æ¬¡é€‰</span>
             <span class="secondaryAns">${secondary}</span>
           </span>`;
      } else {
        displayHTML = `<span class="primaryAns">â‰ˆ ${primary}</span>`;
      }

      display.innerHTML = displayHTML;
      display.setAttribute("data-result", "true");
      display.setAttribute("data-type", "estimate");
      adjustAnswerDisplay();
      setExplanationContent(explanationStr);
      updateEstimateButtonState(); // æ›´æ–°æŒ‰é”®çŠ¶æ€
    }

    // ä¹˜æ³•ä¼°ç®—å‡½æ•°ï¼ˆä¿®å¤å‡½æ•°åå’Œå‚æ•°ï¼‰
    function estimateMultiplication(multiplicand, multiplier) {
      const exactProduct = multiplicand * multiplier;
      let mulCandidates = [];
      
      // å‰ç½®è§„åˆ™
      if (multiplicand < 10 || multiplier < 10) {
        if (multiplicand < 10 && multiplier >= 10) {
          let candidate_front = multiplicand * (Math.ceil(multiplier / 10) * 10);
          mulCandidates.push({
            method: "å‰ç½®è§„åˆ™",
            candidate: candidate_front,
            error: Math.round(Math.abs(candidate_front - exactProduct) * 10) / 10,
            desc: `å› å› å­è¾ƒå°ï¼Œä¿æŒ ${multiplicand} ä¸å˜ï¼Œ${multiplier} å‘ä¸Šèˆå…¥è‡³ ${Math.ceil(multiplier / 10) * 10}ï¼Œæœ€ç»ˆç®—å¼ï¼š${multiplicand} Ã— ${Math.ceil(multiplier / 10) * 10} = ${candidate_front}`
          });
        } else if (multiplier < 10 && multiplicand >= 10) {
          let candidate_front = (Math.ceil(multiplicand / 10) * 10) * multiplier;
          mulCandidates.push({
            method: "å‰ç½®è§„åˆ™",
            candidate: candidate_front,
            error: Math.round(Math.abs(candidate_front - exactProduct) * 10) / 10,
            desc: `å› å› å­è¾ƒå°ï¼Œä¿æŒ ${multiplier} ä¸å˜ï¼Œ${multiplicand} å‘ä¸Šèˆå…¥è‡³ ${Math.ceil(multiplicand / 10) * 10}ï¼Œæœ€ç»ˆç®—å¼ï¼š${Math.ceil(multiplicand / 10) * 10} Ã— ${multiplier} = ${candidate_front}`
          });
        }
      }

      // ç‰¹æ®Šè§„åˆ™
      if (exactProduct < 100) {
        let candidate_special = specialResultRound(exactProduct);
        mulCandidates.push({
          method: "ç‰¹æ®Šè§„åˆ™",
          candidate: candidate_special,
          error: Math.round(Math.abs(candidate_special - exactProduct) * 10) / 10,
          desc: `ç²¾ç¡®ä¹˜ç§¯è¾ƒå°æ—¶é‡‡ç”¨ç‰¹æ®Šå››èˆäº”å…¥æ³•ï¼Œæœ€ç»ˆç®—å¼ï¼š${exactProduct} å˜æˆ ${candidate_special}`
        });
      }

      // åˆ†åˆ«å››èˆäº”å…¥
      let candidate_separate = (Math.round(multiplicand / 10) * 10) * (Math.round(multiplier / 10) * 10);
      mulCandidates.push({
        method: "åˆ†åˆ«å››èˆäº”å…¥",
        candidate: candidate_separate,
        error: Math.round(Math.abs(candidate_separate - exactProduct) * 10) / 10,
        desc: `åˆ†åˆ«å°†ä¸¤ä¸ªä¹˜æ•°å‘æœ€è¿‘10èˆå…¥åç›¸ä¹˜ï¼Œæœ€ç»ˆç®—å¼ï¼š${Math.round(multiplicand / 10) * 10} Ã— ${Math.round(multiplier / 10) * 10} = ${candidate_separate}`
      });

      // ä¸¤è€…å–å°
      let candidate_floor = (Math.floor(multiplicand / 10) * 10) * (Math.floor(multiplier / 10) * 10);
      mulCandidates.push({
        method: "ä¸¤è€…å–å°",
        candidate: candidate_floor,
        error: Math.round(Math.abs(candidate_floor - exactProduct) * 10) / 10,
        desc: `ä¸¤ä¸ªä¹˜æ•°å‡å‘ä¸‹èˆå…¥åç›¸ä¹˜ï¼Œæœ€ç»ˆç®—å¼ï¼š${Math.floor(multiplicand / 10) * 10} Ã— ${Math.floor(multiplier / 10) * 10} = ${candidate_floor}`
      });

      // ä¸€å¤§ä¸€å°
      let candidate_mixed1 = (Math.ceil(multiplicand / 10) * 10) * (Math.floor(multiplier / 10) * 10);
      let candidate_mixed2 = (Math.floor(multiplicand / 10) * 10) * (Math.ceil(multiplier / 10) * 10);
      let candidate_mixed = Math.abs(candidate_mixed1 - exactProduct) <= Math.abs(candidate_mixed2 - exactProduct) ? candidate_mixed1 : candidate_mixed2;
      mulCandidates.push({
        method: "ä¸€å¤§ä¸€å°",
        candidate: candidate_mixed,
        error: Math.round(Math.abs(candidate_mixed - exactProduct) * 10) / 10,
        desc: "é‡‡ç”¨ä¸€å› å­å‘ä¸Šã€å¦ä¸€å› å­å‘ä¸‹èˆå…¥åç›¸ä¹˜ï¼Œæœ€ç»ˆç®—å¼ï¼š" + (candidate_mixed === candidate_mixed1 ? `${Math.ceil(multiplicand / 10) * 10} Ã— ${Math.floor(multiplier / 10) * 10} = ${candidate_mixed}` : `${Math.floor(multiplicand / 10) * 10} Ã— ${Math.ceil(multiplier / 10) * 10} = ${candidate_mixed}`)
      });

      // éƒ½å–å¤§
      let candidate_ceil = (Math.ceil(multiplicand / 10) * 10) * (Math.ceil(multiplier / 10) * 10);
      mulCandidates.push({
        method: "éƒ½å–å¤§",
        candidate: candidate_ceil,
        error: Math.round(Math.abs(candidate_ceil - exactProduct) * 10) / 10,
        desc: `ä¸¤ä¸ªä¹˜æ•°å‡å‘ä¸Šèˆå…¥åç›¸ä¹˜ï¼Œæœ€ç»ˆç®—å¼ï¼š${Math.ceil(multiplicand / 10) * 10} Ã— ${Math.ceil(multiplier / 10) * 10} = ${candidate_ceil}`
      });

      // é«˜å’Œè§„åˆ™
      let candidate_high = Math.round(exactProduct / 100) * 100;
      mulCandidates.push({
        method: "é«˜å’Œè§„åˆ™",
        candidate: candidate_high,
        error: Math.round(Math.abs(candidate_high - exactProduct) * 10) / 10,
        desc: `å°†ç²¾ç¡®ä¹˜ç§¯å››èˆäº”å…¥è‡³æœ€è¿‘100ï¼Œæœ€ç»ˆç®—å¼ï¼š(${exactProduct} / 100) å››èˆäº”å…¥åä¹˜ä»¥100 = ${candidate_high}`
      });

      // å•å› å­è°ƒæ•´
      let candidate_adjust1 = (Math.round(multiplicand / 10) * 10) * multiplier;
      let candidate_adjust2 = multiplicand * (Math.round(multiplier / 10) * 10);
      let candidate_adjust = Math.abs(candidate_adjust1 - exactProduct) <= Math.abs(candidate_adjust2 - exactProduct) ? candidate_adjust1 : candidate_adjust2;
      mulCandidates.push({
        method: "å•å› å­è°ƒæ•´",
        candidate: candidate_adjust,
        error: Math.round(Math.abs(candidate_adjust - exactProduct) * 10) / 10,
        desc: "ä»…è°ƒæ•´å…¶ä¸­ä¸€ä¸ªä¹˜æ•°ä½¿ä¹˜ç§¯æ›´æ¥è¿‘ç²¾ç¡®å€¼ï¼Œæœ€ç»ˆç®—å¼ï¼š" + (Math.abs(candidate_adjust1 - exactProduct) <= Math.abs(candidate_adjust2 - exactProduct) ? `${Math.round(multiplicand / 10) * 10} Ã— ${multiplier} = ${candidate_adjust}` : `${multiplicand} Ã— ${Math.round(multiplier / 10) * 10} = ${candidate_adjust}`)
      });

      // è®¡ç®—è¯¯å·®å¹¶å»é‡
      mulCandidates.forEach(item => {
        item.error = Math.round(Math.abs(item.candidate - exactProduct) * 10) / 10;
      });

      let uniqueCandidates = [];
      mulCandidates.forEach(item => {
        if (!uniqueCandidates.some(x => x.candidate === item.candidate)) {
          uniqueCandidates.push(item);
        }
      });
      mulCandidates = uniqueCandidates;
      mulCandidates.sort((a, b) => a.error - b.error);

      // å½“ä¹˜æ•°ä½æ•°å¤§äº3æ—¶çš„ç‰¹æ®Šæ’åº
      let multiplicandDigits = String(Math.floor(Math.abs(multiplicand))).length;
      let multiplierDigits = String(Math.floor(Math.abs(multiplier))).length;
      if (multiplicandDigits > 3 || multiplierDigits > 3) {
        let idxLeading = mulCandidates.findIndex(item => item.method === "é¦–ä½ä¼°ç®—æ³•");
        let idxZhengtenshu = mulCandidates.findIndex(item => item.method.indexOf("æ•´åæ•°æ³•") !== -1);
        if (idxLeading !== -1 && idxZhengtenshu !== -1) {
          if (mulCandidates[idxZhengtenshu].error <= mulCandidates[idxLeading].error && idxZhengtenshu > idxLeading) {
            let temp = mulCandidates[idxZhengtenshu];
            mulCandidates.splice(idxZhengtenshu, 1);
            mulCandidates.splice(idxLeading, 0, temp);
          }
        }
      }

      let results = processResults(mulCandidates, exactProduct);
      let primaryMul = results.primary;
      let secondaryMul = results.secondary;

      function countTrailingZeros(num) {
        let s = String(Math.floor(num));
        let m = s.match(/0+$/);
        return m ? m[0].length : 0;
      }
      if (secondaryMul && countTrailingZeros(secondaryMul) > countTrailingZeros(primaryMul)) {
        let temp = primaryMul;
        primaryMul = secondaryMul;
        secondaryMul = temp;
      }

      let explanationStrMul = `åŸç®—å¼ï¼š${multiplicand} Ã— ${multiplier} = ${exactProduct}\n`;
      mulCandidates.forEach(item => {
        explanationStrMul += `ã€${item.method}ã€‘ ${item.desc}ï¼Œä¼°å€¼ä¸º <strong style="font-size:1.1em;">${item.candidate}</strong>ï¼ˆè¯¯å·®: ${item.error.toFixed(1)}ï¼‰\n`;
      });

      // ä¿®å¤ï¼šæ£€æŸ¥æ¬¡é€‰ç»“æœæ˜¯å¦ä¸ºç©º
      let displayHTML;
      if (secondaryMul && secondaryMul !== "") {
        displayHTML = `<span class="primaryAns">â‰ˆ ${primaryMul}</span>
           <span class="separator">/</span>
           <span class="secondaryContainer">
             <span class="secondaryLabel">æ¬¡é€‰</span>
             <span class="secondaryAns">${secondaryMul}</span>
           </span>`;
      } else {
        displayHTML = `<span class="primaryAns">â‰ˆ ${primaryMul}</span>`;
      }

      display.innerHTML = displayHTML;
      display.setAttribute("data-result", "true");
      display.setAttribute("data-type", "estimate");
      adjustAnswerDisplay();
      setExplanationContent(explanationStrMul);
      updateEstimateButtonState(); // æ›´æ–°æŒ‰é”®çŠ¶æ€
    }
    
    // "â‰ˆ" æŒ‰é’®ï¼šå¦‚æœè¡¨è¾¾å¼ä¸­å«æœ‰é™¤å·åˆ™è°ƒç”¨ approximateCalculateï¼ˆé™¤æ³•ï¼‰ï¼Œå¦åˆ™æ ¹æ®å…¶ä»–è¿ç®—è°ƒç”¨ approximateCalculateOther
    function estimate() {
      // æ£€æŸ¥æŒ‰é”®æ˜¯å¦è¢«ç¦ç”¨
      const estimateBtn = document.getElementById('estimateBtn');
      if (estimateBtn.classList.contains('disabled')) {
        return; // å¦‚æœæŒ‰é”®è¢«ç¦ç”¨ï¼Œç›´æ¥è¿”å›
      }

      let expr = exprString.trim();
      if (!expr) return;
      lastExpression = expr;
      equalsPressCount = 0;
      const divisionPattern = /^(-?\d+(?:\.\d+)?)([Ã·/])(-?\d+(?:\.\d+)?)$/;
      const otherPattern = /^(-?\d+(?:\.\d+)?)([+\-Ã—])(-?\d+(?:\.\d+)?)$/;
      if (divisionPattern.test(expr)) {
        approximateCalculate(expr);
      } else if (otherPattern.test(expr)) {
        approximateCalculateOther(expr);
      }
    }
    
    // "=" æŒ‰é’®é€»è¾‘ï¼šé¦–æ¬¡ç‚¹å‡»æ˜¾ç¤ºç²¾ç¡®ç»“æœï¼›ä¹‹åäº¤æ›¿æ˜¾ç¤ºä¼°ç®—ç»“æœä¸ç²¾ç¡®ç»“æœ
    function equalsPressed() {
      if (equalsPressCount === 0) {
        lastExpression = exprString;
        calculate();
        equalsPressCount = 1;
      } else {
        const divisionPattern = /^(-?\d+(?:\.\d+)?)([Ã·/])(-?\d+(?:\.\d+)?)$/;
        const otherPattern = /^(-?\d+(?:\.\d+)?)([+\-Ã—])(-?\d+(?:\.\d+)?)$/;
        if (divisionPattern.test(lastExpression)) {
          if (equalsPressCount % 2 === 1) { 
            approximateCalculate(lastExpression); 
          } else { 
            exprString = lastExpression; 
            calculate(); 
          }
        } else if (otherPattern.test(lastExpression)) {
          if (equalsPressCount % 2 === 1) { 
            approximateCalculateOther(lastExpression); 
          } else { 
            exprString = lastExpression; 
            calculate(); 
          }
        }
        equalsPressCount++;
      }
    }
    
    function exponentOp() { appendValue("^"); }
    function toggleParen() {
      if (!window.parenOpen) { 
        appendValue("("); 
        window.parenOpen = true; 
      } else { 
        appendValue(")"); 
        window.parenOpen = false; 
      }
    }
    
    function formatPrimaryAnswer(answerStr) {
      let n = answerStr.length;
      if (n <= 9) return { displayStr: answerStr, fontSize: "100%", textAlign: "center" };
      else if (n <= 15) return { displayStr: answerStr, fontSize: "70%", textAlign: "center" };
      else {
        if (answerStr.includes(".")) return { displayStr: answerStr, fontSize: "50%", textAlign: "left" };
        else {
          let num = Number(answerStr);
          if (isNaN(num)) return { displayStr: answerStr, fontSize: "60%", textAlign: "center" };
          let sci = num.toExponential(2).replace("e+", "e");
          return { displayStr: sci, fontSize: "60%", textAlign: "center" };
        }
      }
    }
    
    function adjustResultFont(text) {
      if (text.length >= 22) {
        return { text: "ç­”æ¡ˆè¿‡é•¿ï¼Œè¯·è§ä¸‹æ–¹è§£é‡ŠåŒº", scale: 0.65 };
      } else if (text.length >= 19) {
        return { text: text, scale: 0.65 };
      } else if (text.length >= 16) {
        return { text: text, scale: 0.8 };
      }
      return { text: text, scale: 1 };
    }
    
    function adjustAnswerDisplay() {
      const primaryElem = document.querySelector('.primaryAns');
      if (!primaryElem) return;
      let ansText = primaryElem.textContent.trim();
      let fmt = formatPrimaryAnswer(ansText);
      primaryElem.style.fontSize = fmt.fontSize;
      
      const sepElem = document.querySelector('.separator');
      if (sepElem) {
        if (display.getAttribute("data-type") === "estimate") {
          sepElem.style.fontSize = "0.7em";
          sepElem.style.marginRight = "6px";
          sepElem.style.top = "3px";
        } else {
          sepElem.style.fontSize = fmt.fontSize;
        }
      }
      
      const secondaryElem = document.querySelector('.secondaryContainer');
      if (secondaryElem) secondaryElem.style.fontSize = fmt.fontSize;
      display.style.textAlign = fmt.textAlign;
    }
    
    document.addEventListener("keydown", function(e) {
      const key = e.key;
      if (document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA")
        return;
      if ((key >= "0" && key <= "9") || key === ".") { appendValue(key); e.preventDefault(); }
      else if (key === "+") { appendValue("+"); e.preventDefault(); }
      else if (key === "-") { appendValue("-"); e.preventDefault(); }
      else if (key === "*" || key.toLowerCase() === "x") { appendValue("Ã—"); e.preventDefault(); }
      else if (key === "/" || key === "Ã·") { appendValue("Ã·"); e.preventDefault(); }
      else if (key === "(") { appendValue("("); e.preventDefault(); }
      else if (key === ")") { appendValue(")"); e.preventDefault(); }
      else if (key === "Enter" || key === "=") { equalsPressed(); e.preventDefault(); }
      else if (key === "Backspace") { backspace(); e.preventDefault(); }
      else if (key === "Delete" || key === "Escape") { clearDisplay(); e.preventDefault(); }
      else if (key === "^") { exponentOp(); e.preventDefault(); }
    });

    // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–æŒ‰é”®çŠ¶æ€
    document.addEventListener("DOMContentLoaded", function() {
      updateEstimateButtonState();
    });
  </script>
</body>
</html>